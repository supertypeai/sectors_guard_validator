name: IDX Data Validation Schedules

on:
  schedule:
    # Daily completeness/coverage for idx_daily_data - Daily at 12 AM UTC
    - cron: '0 0 * * *'
    # Annual financials - 3x a year (Mar, Apr, Jun) on the 16th at 2 AM UTC
    - cron: '0 2 16 3,4,6 *'
    # Quarterly financials - Monthly on the 1st at 3 AM UTC  
    - cron: '0 3 1 * *'
    # Daily data - Weekly every Monday at 1 AM UTC
    - cron: '0 1 * * 1'
    # Dividend - Monthly on the 1st at 4 AM UTC
    - cron: '0 4 1 * *'
    # All-time price - Daily at 5 AM UTC
    - cron: '0 5 * * *'
    # Filings - Daily at 9.15 AM UTC
    - cron: '15 9 * * *'
    # Stock split - Monthly on the 1st at 7 AM UTC
    - cron: '0 7 1 * *'
    # SGX company report - Monthly on the 16th at 07:00 UTC
    - cron: '0 7 16 * *'
    # Index daily data - Monthly on the 1st at 8 AM UTC
    - cron: '0 8 1 * *'
    # News - Monthly on the 1st at 9 AM UTC
    - cron: '0 9 1 * *'
    # SGX manual input - Every 6 months (Jan and Jul) on the 1st at 10 AM UTC
    - cron: '0 10 1 1,7 *'
    # Company profile - Monthly on the 29th at 11 AM UTC
    - cron: '0 11 29 * *'
    # SGX Filings - Weekdays (Mon-Fri) at 6 AM UTC
    - cron: '0 6 * * 1-5' 

  workflow_dispatch:
    inputs:
      validation_type:
        description: 'Choose validation type to run'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'annual'
          - 'quarterly' 
          - 'daily'
          - 'dividend'
          - 'alltime'
          - 'filings'
          - 'stocksplit'
          - 'daily_completeness'
          - 'index_daily'
          - 'news'
          - 'sgx_company_report'
          - 'sgx_manual_input'
          - 'company_profile'
          - 'sgx_filings'

env:
  PYTHON_VERSION: '3.11'

jobs:
  determine-validation-type:
    runs-on: ubuntu-latest
    outputs:
      validation_tables: ${{ steps.determine.outputs.validation_tables }}
      
    steps:
    - name: Determine which validations to run
      id: determine
      run: |
        # Get current date info
        month=$(date +%m)
        day=$(date +%d)
        weekday=$(date +%u)  # 1=Monday, 7=Sunday
        validation_tables=""
        
        echo "Debug: Event name = ${{ github.event_name }}"
        echo "Debug: Month = $month, Day = $day, Weekday = $weekday"
        
        # Manual trigger
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          case "${{ github.event.inputs.validation_type }}" in
            "annual")
              validation_tables=idx_combine_financials_annual
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "quarterly")
              validation_tables=idx_combine_financials_quarterly
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "daily")
              validation_tables=idx_daily_data
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "daily_completeness")
              validation_tables=idx_daily_data_completeness
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "index_daily")
              validation_tables=index_daily_data
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "dividend")
              validation_tables=idx_dividend
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "alltime")
              validation_tables=idx_all_time_price
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "filings")
              validation_tables=idx_filings
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "stocksplit")
              validation_tables=idx_stock_split
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "news")
              validation_tables=idx_news
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "sgx_company_report")
              validation_tables=sgx_company_report
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "sgx_manual_input")
              validation_tables=sgx_manual_input
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "company_profile")
              validation_tables=idx_company_profile
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "sgx_filings")
              validation_tables=sgx_filings
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
            "all")
              validation_tables=idx_combine_financials_annual,idx_combine_financials_quarterly,idx_daily_data,idx_daily_data_completeness,index_daily_data,idx_dividend,idx_all_time_price,idx_filings,idx_stock_split,idx_news,sgx_company_report,sgx_manual_input,idx_company_profile,sgx_filings
              echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
              ;;
          esac
        else
          # Scheduled trigger - determine based on cron schedule
          
          # Daily completeness - runs daily at 12 AM UTC
          if [ "${{ github.event.schedule }}" = "0 0 * * *" ]; then
            validation_tables=idx_daily_data_completeness
            
          # Annual financials - 3x a year (Mar, Apr, Jun) on 16th at 2 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 2 16 3,4,6 *" ]; then
            validation_tables=idx_combine_financials_annual
            
          # Quarterly financials - Monthly on 1st at 3 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 3 1 * *" ]; then
            validation_tables=idx_combine_financials_quarterly
            
          # Daily data - Weekly every Monday at 1 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 1 * * 1" ]; then
            validation_tables=idx_daily_data
            
          # Dividend - Monthly on 1st at 4 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 4 1 * *" ]; then
            validation_tables=idx_dividend
            
          # All-time price - Daily at 5 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 5 * * *" ]; then
            validation_tables=idx_all_time_price
            
          # Filings - Daily at 9:15 AM UTC
          elif [ "${{ github.event.schedule }}" = "15 9 * * *" ]; then
            validation_tables=idx_filings
            
          # Stock split - Monthly on 1st at 7 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 7 1 * *" ]; then
            validation_tables=idx_stock_split
            
          # SGX company report - Monthly on 16th at 7 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 7 16 * *" ]; then
            validation_tables=sgx_company_report
            
          # Index daily data - Monthly on 1st at 8 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 8 1 * *" ]; then
            validation_tables=index_daily_data
            
          # News - Monthly on 1st at 9 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 9 1 * *" ]; then
            validation_tables=idx_news
            
          # SGX manual input - Every 6 months (Jan & Jul) on 1st at 10 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 10 1 1,7 *" ]; then
            validation_tables=sgx_manual_input
            
          # Company profile - Monthly on 29th at 11 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 11 29 * *" ]; then
            validation_tables=idx_company_profile
            
          # SGX Filings - Weekdays (Mon-Fri) at 6 AM UTC
          elif [ "${{ github.event.schedule }}" = "0 6 * * 1-5" ]; then
            validation_tables=sgx_filings
            
          fi
          
          echo "Debug: Schedule = ${{ github.event.schedule }}"
          echo "Debug: Determined tables = $validation_tables"
        fi
        
        # Set output - either determined tables or 'none' as fallback
        if [ -z "$validation_tables" ]; then
          validation_tables=none
        fi
        
        echo "validation_tables=$validation_tables" >> $GITHUB_OUTPUT
        echo "Final output: validation_tables=$validation_tables"

  data-validation:
    needs: determine-validation-type
    runs-on: ubuntu-latest
    if: needs.determine-validation-type.outputs.validation_tables != 'none'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install requests library
      run: |
        python -m pip install --upgrade pip
        pip install requests

    - name: Run data validation via API
      env:
        TABLES_TO_VALIDATE: ${{ needs.determine-validation-type.outputs.validation_tables }}
        API_BASE_URL: https://sectors-guard-validator.fly.dev
        BACKEND_API_TOKEN: ${{ secrets.BACKEND_API_TOKEN }}
      run: |
        python -c "
        import requests
        import sys
        import os
        import json
        import time
        from datetime import datetime
        
        # Get configuration from environment
        tables_env = os.getenv('TABLES_TO_VALIDATE', '')
        api_base_url = os.getenv('API_BASE_URL', 'https://sectors-guard-validator.fly.dev')
        api_token = os.getenv('BACKEND_API_TOKEN')
        
        # Retry configuration
        MAX_RETRIES = 5
        INITIAL_BACKOFF = 60  # seconds
        
        if not api_token:
            print('::error::BACKEND_API_TOKEN not configured')
            sys.exit(1)
        
        if not tables_env or tables_env == 'none':
            print('No tables to validate.')
            sys.exit(0)
        
        tables_to_validate = [t.strip() for t in tables_env.split(',') if t.strip()]
        print(f'üìã Tables to validate: {tables_to_validate}')
        print(f'üåê API URL: {api_base_url}')
        print(f'üîÑ Retry configuration: max_retries={MAX_RETRIES}, exponential_backoff')
        
        # Prepare request headers
        headers = {
            'Authorization': f'Bearer {api_token}',
            'Content-Type': 'application/json'
        }
        
        def should_retry(status_code=None, exception=None):
            # Retry on network errors
            if exception:
                if isinstance(exception, (requests.exceptions.ConnectionError, 
                                         requests.exceptions.Timeout,
                                         requests.exceptions.RequestException)):
                    return True
            # Retry on 5xx server errors
            if status_code and 500 <= status_code < 600:
                return True
            return False
        
        def make_request_with_retry(table_name, max_retries=MAX_RETRIES):
            last_exception = None
            last_response = None
            
            for attempt in range(max_retries + 1):
                try:
                    if attempt > 0:
                        backoff_time = INITIAL_BACKOFF * (2 ** (attempt - 1))
                        print(f'Retry attempt {attempt}/{max_retries} for {table_name} after {backoff_time}s delay...')
                        time.sleep(backoff_time)
                    
                    # Call API endpoint
                    response = requests.post(
                        f'{api_base_url}/api/validation/run/{table_name}',
                        headers=headers,
                        timeout=900  # 15 minutes timeout for large datasets
                    )
                    
                    # Check if we should retry based on status code
                    if should_retry(status_code=response.status_code):
                        last_response = response
                        if attempt < max_retries:
                            print(f'‚ö†Ô∏è  HTTP {response.status_code} error - will retry')
                            continue
                        else:
                            print(f'‚ùå Max retries reached for {table_name}')
                            return response
                    
                    # Success or non-retryable error
                    return response
                    
                except requests.exceptions.Timeout as e:
                    last_exception = e
                    if attempt < max_retries:
                        print(f'‚ö†Ô∏è  Timeout error - will retry')
                        continue
                    else:
                        print(f'‚ùå Max retries reached for {table_name}')
                        raise
                        
                except requests.exceptions.RequestException as e:
                    last_exception = e
                    if should_retry(exception=e) and attempt < max_retries:
                        print(f'‚ö†Ô∏è  Network error - will retry')
                        continue
                    else:
                        if attempt >= max_retries:
                            print(f'‚ùå Max retries reached for {table_name}')
                        raise
            
            # If we get here, we've exhausted retries
            if last_response:
                return last_response
            if last_exception:
                raise last_exception
        
        total_anomalies = 0
        results_summary = []
        
        # Validate each table via API
        for table_name in tables_to_validate:
            print(f'\\nValidating table: {table_name}')
            
            try:
                # Call API endpoint with retry mechanism
                response = make_request_with_retry(table_name)
                
                if response.status_code == 200:
                    result = response.json()
                    anomalies_count = result.get('anomalies_count', 0)
                    total_anomalies += anomalies_count
                    
                    results_summary.append({
                        'table': table_name,
                        'status': result.get('status', 'success'),
                        'anomalies': anomalies_count,
                        'validation_timestamp': result.get('validation_timestamp'),
                        'email_sent': result.get('email_sent', False)
                    })
                    
                    if anomalies_count > 0:
                        print(f'‚ö†Ô∏è  {table_name}: {anomalies_count} anomalies detected')
                        if result.get('email_sent'):
                            print(f'Email notification sent for {table_name}')
                    else:
                        print(f'‚úÖ {table_name}: No anomalies found')
                        
                elif response.status_code == 401:
                    print(f'::error::Authentication failed for {table_name}: Invalid BACKEND_API_TOKEN')
                    results_summary.append({
                        'table': table_name,
                        'status': 'error',
                        'anomalies': 0,
                        'error': 'Authentication failed'
                    })
                    sys.exit(1)
                    
                elif response.status_code == 403:
                    print(f'::error::Authorization failed for {table_name}: Access denied')
                    results_summary.append({
                        'table': table_name,
                        'status': 'error',
                        'anomalies': 0,
                        'error': 'Authorization failed'
                    })
                    sys.exit(1)
                    
                else:
                    error_msg = response.text
                    print(f'‚ùå Error validating {table_name}: HTTP {response.status_code} - {error_msg}')
                    results_summary.append({
                        'table': table_name,
                        'status': 'error',
                        'anomalies': 0,
                        'error': f'HTTP {response.status_code}: {error_msg}'
                    })
                    
            except requests.exceptions.Timeout:
                print(f'‚ùå Timeout validating {table_name}: Request exceeded 10 minutes')
                results_summary.append({
                    'table': table_name,
                    'status': 'error',
                    'anomalies': 0,
                    'error': 'Request timeout'
                })
                
            except requests.exceptions.RequestException as e:
                print(f'‚ùå Network error validating {table_name}: {str(e)}')
                results_summary.append({
                    'table': table_name,
                    'status': 'error',
                    'anomalies': 0,
                    'error': f'Network error: {str(e)}'
                })
                
            except Exception as e:
                print(f'‚ùå Unexpected error validating {table_name}: {str(e)}')
                results_summary.append({
                    'table': table_name,
                    'status': 'error',
                    'anomalies': 0,
                    'error': str(e)
                })
        
        # Print summary
        print(f'\\n=== Validation Summary ===')
        print(f'Tables validated: {len(tables_to_validate)}')
        print(f'Total anomalies detected: {total_anomalies}')
        print(f'Tables with errors: {len([r for r in results_summary if r[\"status\"] == \"error\"])}')
        
        for result in results_summary:
            status_emoji = '‚úÖ' if result['status'] == 'success' and result['anomalies'] == 0 else '‚ö†Ô∏è' if result['status'] == 'success' else '‚ùå'
            anomaly_text = f\"({result['anomalies']} anomalies)\" if result['status'] == 'success' else f\"({result.get('error', 'unknown error')})\"
            print(f\"{status_emoji} {result['table']}: {result['status']} {anomaly_text}\")
        
        # Set GitHub Actions output for notifications
        if total_anomalies > 0:
            print(f'::warning::Found {total_anomalies} anomalies across {len([r for r in results_summary if r.get(\"anomalies\", 0) > 0])} tables')
        else:
            print(f'::notice::All validations completed successfully with no anomalies detected')
        
        # Check if any validation had errors
        error_count = len([r for r in results_summary if r['status'] == 'error'])
        if error_count > 0:
            print(f'::error::{error_count} table(s) failed validation')
            sys.exit(1)
        
        # Save results
        with open('validation_results.json', 'w') as f:
            json.dump({
                'summary': {
                    'total_tables': len(tables_to_validate),
                    'total_anomalies': total_anomalies,
                    'tables_with_anomalies': len([r for r in results_summary if r.get('anomalies', 0) > 0]),
                    'tables_with_errors': error_count
                },
                'results': results_summary,
                'timestamp': datetime.utcnow().isoformat()
            }, f, indent=2)
        print('\\nüíæ Results saved to validation_results.json')
        "


    - name: Create validation report
      if: always()
      run: |
        python -c "
        import json
        from datetime import datetime
        import os
        
        # Create a comprehensive validation report
        report = {
            'workflow_info': {
                'timestamp': datetime.utcnow().isoformat(),
                'workflow_run': '${{ github.run_id }}',
                'workflow_name': '${{ github.workflow }}',
                'event_name': '${{ github.event_name }}',
                'repository': '${{ github.repository }}',
                'branch': '${{ github.ref_name }}',
                'commit_sha': '${{ github.sha }}'
            },
            'validation_config': {
                'tables_to_validate': os.getenv('TABLES_TO_VALIDATE', 'none'),
                'trigger_type': '${{ github.event_name }}',
                'manual_input': '${{ github.event.inputs.validation_type }}' if '${{ github.event_name }}' == 'workflow_dispatch' else 'scheduled'
            },
            'status': 'completed'
        }
        
        # Try to merge with validation results if exists
        try:
            with open('validation_results.json', 'r') as f:
                validation_results = json.load(f)
                report['validation_results'] = validation_results
        except FileNotFoundError:
            report['validation_results'] = {'summary': {'total_tables': 0, 'total_anomalies': 0}, 'results': []}
        
        with open('validation_report.json', 'w') as f:
            json.dump(report, f, indent=2)
        
        print('üìÑ Validation report created')
        "

    - name: Upload validation report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: validation-report-${{ github.run_id }}
        path: |
          validation_report.json
          validation_results.json
        retention-days: 30
        if-no-files-found: warn

    - name: Notify on failure
      if: failure()
      run: |
        echo "::error::Data validation workflow failed. Please check the logs and investigate."
